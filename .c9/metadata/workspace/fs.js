{"changed":false,"filter":false,"title":"fs.js","tooltip":"/fs.js","value":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that octal literals are not allowed\n// in strict mode. Use the decimal value and add a comment with\n// the octal value. Example:\n//\n//   var mode = 438; /* mode=0666 */\n\nvar util = require('util');\nvar pathModule = require('path');\n\nvar binding = process.binding('fs');\nvar constants = process.binding('constants');\nvar fs = exports;\nvar Stream = require('stream').Stream;\nvar EventEmitter = require('events').EventEmitter;\n\nvar Readable = Stream.Readable;\nvar Writable = Stream.Writable;\n\nvar kMinPoolSpace = 128;\n\nvar O_APPEND = constants.O_APPEND || 0;\nvar O_CREAT = constants.O_CREAT || 0;\nvar O_DIRECTORY = constants.O_DIRECTORY || 0;\nvar O_EXCL = constants.O_EXCL || 0;\nvar O_NOCTTY = constants.O_NOCTTY || 0;\nvar O_NOFOLLOW = constants.O_NOFOLLOW || 0;\nvar O_RDONLY = constants.O_RDONLY || 0;\nvar O_RDWR = constants.O_RDWR || 0;\nvar O_SYMLINK = constants.O_SYMLINK || 0;\nvar O_SYNC = constants.O_SYNC || 0;\nvar O_TRUNC = constants.O_TRUNC || 0;\nvar O_WRONLY = constants.O_WRONLY || 0;\n\nvar isWindows = process.platform === 'win32';\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (typeof cb !== 'function') {\n    return rethrow();\n  }\n\n  return function() {\n    return cb.apply(null, arguments);\n  };\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\nfunction nullCheck(path, callback) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    var er = new Error('Path must be a string without null bytes.');\n    if (!callback)\n      throw er;\n    process.nextTick(function() {\n      callback(er);\n    });\n    return false;\n  }\n  return true;\n}\n\nfs.Stats = binding.Stats;\n\nfs.Stats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\n\nfs.Stats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\nfs.Stats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\nfs.Stats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\nfs.Stats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\nfs.Stats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\nfs.Stats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\nfs.Stats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\nfs.exists = function(path, callback) {\n  if (!nullCheck(path, cb)) return;\n  binding.stat(pathModule._makeLong(path), cb);\n  function cb(err, stats) {\n    if (callback) callback(err ? false : true);\n  }\n};\n\nfs.existsSync = function(path) {\n  try {\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nfs.readFile = function(path, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (typeof options === 'function' || !options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, flag: 'r' };\n  } else if (!options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var fd;\n\n  var flag = options.flag || 'r';\n  fs.open(path, flag, 438 /*=0666*/, function(er, fd_) {\n    if (er) return callback(er);\n    fd = fd_;\n\n    fs.fstat(fd, function(er, st) {\n      if (er) {\n        return fs.close(fd, function() {\n          callback(er);\n        });\n      }\n\n      size = st.size;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      buffer = new Buffer(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = new Buffer(8192);\n      fs.read(fd, buffer, 0, 8192, -1, afterRead);\n    } else {\n      fs.read(fd, buffer, pos, size - pos, -1, afterRead);\n    }\n  }\n\n  function afterRead(er, bytesRead) {\n    if (er) {\n      return fs.close(fd, function(er2) {\n        return callback(er);\n      });\n    }\n\n    if (bytesRead === 0) {\n      return close();\n    }\n\n    pos += bytesRead;\n    if (size !== 0) {\n      if (pos === size) close();\n      else read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, bytesRead));\n      read();\n    }\n  }\n\n  function close() {\n    fs.close(fd, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size) {\n        buffer = buffer.slice(0, pos);\n      }\n\n      if (encoding) buffer = buffer.toString(encoding);\n      return callback(er, buffer);\n    });\n  }\n};\n\nfs.readFileSync = function(path, options) {\n  if (!options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, flag: 'r' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  var flag = options.flag || 'r';\n  var fd = fs.openSync(path, flag, 438 /*=0666*/);\n\n  var size;\n  var threw = true;\n  try {\n    size = fs.fstatSync(fd).size;\n    threw = false;\n  } finally {\n    if (threw) fs.closeSync(fd);\n  }\n\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    var threw = true;\n    try {\n      buffer = new Buffer(size);\n      threw = false;\n    } finally {\n      if (threw) fs.closeSync(fd);\n    }\n  }\n\n  var done = false;\n  while (!done) {\n    var threw = true;\n    try {\n      if (size !== 0) {\n        var bytesRead = fs.readSync(fd, buffer, pos, size - pos);\n      } else {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffer = new Buffer(8192);\n        var bytesRead = fs.readSync(fd, buffer, 0, 8192);\n        if (bytesRead) {\n          buffers.push(buffer.slice(0, bytesRead));\n        }\n      }\n      threw = false;\n    } finally {\n      if (threw) fs.closeSync(fd);\n    }\n\n    pos += bytesRead;\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\n  }\n\n  fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (encoding) buffer = buffer.toString(encoding);\n  return buffer;\n};\n\n\n// Used by binding.open and friends\nfunction stringToFlags(flag) {\n  // Only mess with strings\n  if (typeof flag !== 'string') {\n    return flag;\n  }\n\n  // O_EXCL is mandated by POSIX, Windows supports it too.\n  // Let's add a check anyway, just in case.\n  if (!O_EXCL && ~flag.indexOf('x')) {\n    throw errnoException('ENOSYS', 'fs.open(O_EXCL)');\n  }\n\n  switch (flag) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // fall through\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // fall through\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // fall through\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // fall through\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n  }\n\n  throw new Error('Unknown file open flag: ' + flag);\n}\n\n// exported but hidden, only used by test/simple/test-fs-open-flags.js\nObject.defineProperty(exports, '_stringToFlags', {\n  enumerable: false,\n  value: stringToFlags\n});\n\n\n// Yes, the follow could be easily DRYed up but I provide the explicit\n// list to make the arguments clear.\n\nfs.close = function(fd, callback) {\n  binding.close(fd, makeCallback(callback));\n};\n\nfs.closeSync = function(fd) {\n  return binding.close(fd);\n};\n\nfunction modeNum(m, def) {\n  switch (typeof m) {\n    case 'number': return m;\n    case 'string': return parseInt(m, 8);\n    default:\n      if (def) {\n        return modeNum(def);\n      } else {\n        return undefined;\n      }\n  }\n}\n\nfs.open = function(path, flags, mode, callback) {\n  callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 438 /*=0666*/);\n\n  if (!nullCheck(path, callback)) return;\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               callback);\n};\n\nfs.openSync = function(path, flags, mode) {\n  mode = modeNum(mode, 438 /*=0666*/);\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n};\n\nfs.read = function(fd, buffer, offset, length, position, callback) {\n  if (!Buffer.isBuffer(buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    var cb = arguments[4],\n        encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n    offset = 0;\n\n    callback = function(err, bytesRead) {\n      if (!cb) return;\n\n      var str = (bytesRead > 0) ? buffer.toString(encoding, 0, bytesRead) : '';\n\n      (cb)(err, str, bytesRead);\n    };\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  binding.read(fd, buffer, offset, length, position, wrapper);\n};\n\nfs.readSync = function(fd, buffer, offset, length, position) {\n  var legacy = false;\n  if (!Buffer.isBuffer(buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    legacy = true;\n    var encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n\n    offset = 0;\n  }\n\n  var r = binding.read(fd, buffer, offset, length, position);\n  if (!legacy) {\n    return r;\n  }\n\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\n  return [str, r];\n};\n\nfs.write = function(fd, buffer, offset, length, position, callback) {\n  if (!Buffer.isBuffer(buffer)) {\n    // legacy string interface (fd, data, position, encoding, callback)\n    callback = arguments[4];\n    position = arguments[2];\n    assertEncoding(arguments[3]);\n\n    buffer = new Buffer('' + arguments[1], arguments[3]);\n    offset = 0;\n    length = buffer.length;\n  }\n\n  if (!length) {\n    if (typeof callback == 'function') {\n      process.nextTick(function() {\n        callback(undefined, 0);\n      });\n    }\n    return;\n  }\n\n  callback = maybeCallback(callback);\n\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  binding.write(fd, buffer, offset, length, position, wrapper);\n};\n\nfs.writeSync = function(fd, buffer, offset, length, position) {\n  if (!Buffer.isBuffer(buffer)) {\n    // legacy string interface (fd, data, position, encoding)\n    position = arguments[2];\n    assertEncoding(arguments[3]);\n\n    buffer = new Buffer('' + arguments[1], arguments[3]);\n    offset = 0;\n    length = buffer.length;\n  }\n  if (!length) return 0;\n\n  return binding.write(fd, buffer, offset, length, position);\n};\n\nfs.rename = function(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 callback);\n};\n\nfs.renameSync = function(oldPath, newPath) {\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n};\n\nfs.truncate = function(path, len, callback) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (typeof len === 'undefined') {\n    len = 0;\n  }\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    binding.ftruncate(fd, len, function(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    });\n  });\n};\n\nfs.truncateSync = function(path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (typeof len === 'undefined') {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  try {\n    var ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n};\n\nfs.ftruncate = function(fd, len, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (typeof len === 'undefined') {\n    len = 0;\n  }\n  binding.ftruncate(fd, len, makeCallback(callback));\n};\n\nfs.ftruncateSync = function(fd, len) {\n  if (typeof len === 'undefined') {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n};\n\nfs.rmdir = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.rmdir(pathModule._makeLong(path), callback);\n};\n\nfs.rmdirSync = function(path) {\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n};\n\nfs.fdatasync = function(fd, callback) {\n  binding.fdatasync(fd, makeCallback(callback));\n};\n\nfs.fdatasyncSync = function(fd) {\n  return binding.fdatasync(fd);\n};\n\nfs.fsync = function(fd, callback) {\n  binding.fsync(fd, makeCallback(callback));\n};\n\nfs.fsyncSync = function(fd) {\n  return binding.fsync(fd);\n};\n\nfs.mkdir = function(path, mode, callback) {\n  if (typeof mode === 'function') callback = mode;\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 511 /*=0777*/),\n                callback);\n};\n\nfs.mkdirSync = function(path, mode) {\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 511 /*=0777*/));\n};\n\nfs.readdir = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.readdir(pathModule._makeLong(path), callback);\n};\n\nfs.readdirSync = function(path) {\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path));\n};\n\nfs.fstat = function(fd, callback) {\n  binding.fstat(fd, makeCallback(callback));\n};\n\nfs.lstat = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.lstat(pathModule._makeLong(path), callback);\n};\n\nfs.stat = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.stat(pathModule._makeLong(path), callback);\n};\n\nfs.fstatSync = function(fd) {\n  return binding.fstat(fd);\n};\n\nfs.lstatSync = function(path) {\n  nullCheck(path);\n  return binding.lstat(pathModule._makeLong(path));\n};\n\nfs.statSync = function(path) {\n  nullCheck(path);\n  return binding.stat(pathModule._makeLong(path));\n};\n\nfs.readlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.readlink(pathModule._makeLong(path), callback);\n};\n\nfs.readlinkSync = function(path) {\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path));\n};\n\nfunction preprocessSymlinkDestination(path, type) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  } else if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    return pathModule._makeLong(path);\n  } else {\n    // Windows symlinks don't tolerate forward slashes.\n    return ('' + path).replace(/\\//g, '\\\\');\n  }\n}\n\nfs.symlink = function(destination, path, type_, callback) {\n  var type = (typeof type_ === 'string' ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (!nullCheck(destination, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  binding.symlink(preprocessSymlinkDestination(destination, type),\n                  pathModule._makeLong(path),\n                  type,\n                  callback);\n};\n\nfs.symlinkSync = function(destination, path, type) {\n  type = (typeof type === 'string' ? type : null);\n\n  nullCheck(destination);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(destination, type),\n                         pathModule._makeLong(path),\n                         type);\n};\n\nfs.link = function(srcpath, dstpath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(srcpath, callback)) return;\n  if (!nullCheck(dstpath, callback)) return;\n\n  binding.link(pathModule._makeLong(srcpath),\n               pathModule._makeLong(dstpath),\n               callback);\n};\n\nfs.linkSync = function(srcpath, dstpath) {\n  nullCheck(srcpath);\n  nullCheck(dstpath);\n  return binding.link(pathModule._makeLong(srcpath),\n                      pathModule._makeLong(dstpath));\n};\n\nfs.unlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.unlink(pathModule._makeLong(path), callback);\n};\n\nfs.unlinkSync = function(path) {\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n};\n\nfs.fchmod = function(fd, mode, callback) {\n  binding.fchmod(fd, modeNum(mode), makeCallback(callback));\n};\n\nfs.fchmodSync = function(fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n};\n\nif (constants.hasOwnProperty('O_SYMLINK')) {\n  fs.lchmod = function(path, mode, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function(err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2);\n        });\n      });\n    });\n  };\n\n  fs.lchmodSync = function(path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2;\n    try {\n      var ret = fs.fchmodSync(fd, mode);\n    } catch (er) {\n      err = er;\n    }\n    try {\n      fs.closeSync(fd);\n    } catch (er) {\n      err2 = er;\n    }\n    if (err || err2) throw (err || err2);\n    return ret;\n  };\n}\n\n\nfs.chmod = function(path, mode, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                callback);\n};\n\nfs.chmodSync = function(path, mode) {\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n};\n\nif (constants.hasOwnProperty('O_SYMLINK')) {\n  fs.lchown = function(path, uid, gid, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fs.fchown(fd, uid, gid, callback);\n    });\n  };\n\n  fs.lchownSync = function(path, uid, gid) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n    return fs.fchownSync(fd, uid, gid);\n  };\n}\n\nfs.fchown = function(fd, uid, gid, callback) {\n  binding.fchown(fd, uid, gid, makeCallback(callback));\n};\n\nfs.fchownSync = function(fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n};\n\nfs.chown = function(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.chown(pathModule._makeLong(path), uid, gid, callback);\n};\n\nfs.chownSync = function(path, uid, gid) {\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n};\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n  if (typeof time == 'number') {\n    return time;\n  }\n  if (time instanceof Date) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}\n\n// exported for unit tests, not for public consumption\nfs._toUnixTimestamp = toUnixTimestamp;\n\nfs.utimes = function(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 callback);\n};\n\nfs.utimesSync = function(path, atime, mtime) {\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n};\n\nfs.futimes = function(fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime, makeCallback(callback));\n};\n\nfs.futimesSync = function(fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n};\n\nfunction writeAll(fd, buffer, offset, length, position, callback) {\n  callback = maybeCallback(arguments[arguments.length - 1]);\n\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\n    if (writeErr) {\n      fs.close(fd, function() {\n        if (callback) callback(writeErr);\n      });\n    } else {\n      if (written === length) {\n        fs.close(fd, callback);\n      } else {\n        offset += written;\n        length -= written;\n        position += written;\n        writeAll(fd, buffer, offset, length, position, callback);\n      }\n    }\n  });\n}\n\nfs.writeFile = function(path, data, options, callback) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (typeof options === 'function' || !options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 438, flag: 'w' };\n  } else if (!options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      if (callback) callback(openErr);\n    } else {\n      var buffer = Buffer.isBuffer(data) ? data : new Buffer('' + data,\n          options.encoding || 'utf8');\n      var position = /a/.test(flag) ? null : 0;\n      writeAll(fd, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\n\nfs.writeFileSync = function(path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 438, flag: 'w' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  var fd = fs.openSync(path, flag, options.mode);\n  if (!Buffer.isBuffer(data)) {\n    data = new Buffer('' + data, options.encoding || 'utf8');\n  }\n  var written = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (written < length) {\n      written += fs.writeSync(fd, data, written, length - written, position);\n      position += written;\n    }\n  } finally {\n    fs.closeSync(fd);\n  }\n};\n\nfs.appendFile = function(path, data, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (typeof options === 'function' || !options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 438, flag: 'a' };\n  } else if (!options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  fs.writeFile(path, data, options, callback);\n};\n\nfs.appendFileSync = function(path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  } else if (typeof options === 'string') {\n    options = { encoding: options, mode: 438, flag: 'a' };\n  } else if (typeof options !== 'object') {\n    throw new TypeError('Bad arguments');\n  }\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n\n  fs.writeFileSync(path, data, options);\n};\n\nfunction errnoException(errorno, syscall) {\n  // TODO make this more compatible with ErrnoException from src/node.cc\n  // Once all of Node is using this function the ErrnoException from\n  // src/node.cc should be removed.\n  var e = new Error(syscall + ' ' + errorno);\n  e.errno = e.code = errorno;\n  e.syscall = syscall;\n  return e;\n}\n\n\nfunction FSWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  var FSEvent = process.binding('fs_event_wrap').FSEvent;\n  this._handle = new FSEvent();\n  this._handle.owner = this;\n\n  this._handle.onchange = function(status, event, filename) {\n    if (status) {\n      self._handle.close();\n      self.emit('error', errnoException(process._errno, 'watch'));\n    } else {\n      self.emit('change', event, filename);\n    }\n  };\n}\nutil.inherits(FSWatcher, EventEmitter);\n\nFSWatcher.prototype.start = function(filename, persistent) {\n  nullCheck(filename);\n  var r = this._handle.start(pathModule._makeLong(filename), persistent);\n\n  if (r) {\n    this._handle.close();\n    throw errnoException(process._errno, 'watch');\n  }\n};\n\nFSWatcher.prototype.close = function() {\n  this._handle.close();\n};\n\nfs.watch = function(filename) {\n  nullCheck(filename);\n  var watcher;\n  var options;\n  var listener;\n\n  if ('object' == typeof arguments[1]) {\n    options = arguments[1];\n    listener = arguments[2];\n  } else {\n    options = {};\n    listener = arguments[1];\n  }\n\n  if (options.persistent === undefined) options.persistent = true;\n\n  watcher = new FSWatcher();\n  watcher.start(filename, options.persistent);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n};\n\n\n// Stat Change Watchers\n\nfunction StatWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new binding.StatWatcher();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility\n  var oldStatus = -1;\n\n  this._handle.onchange = function(current, previous, newStatus) {\n    if (oldStatus === -1 &&\n        newStatus === -1 &&\n        current.nlink === previous.nlink) return;\n\n    oldStatus = newStatus;\n    self.emit('change', current, previous);\n  };\n\n  this._handle.onstop = function() {\n    self.emit('stop');\n  };\n}\nutil.inherits(StatWatcher, EventEmitter);\n\n\nStatWatcher.prototype.start = function(filename, persistent, interval) {\n  nullCheck(filename);\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\n};\n\n\nStatWatcher.prototype.stop = function() {\n  this._handle.stop();\n};\n\n\nvar statWatchers = {};\nfunction inStatWatchers(filename) {\n  return Object.prototype.hasOwnProperty.call(statWatchers, filename) &&\n      statWatchers[filename];\n}\n\n\nfs.watchFile = function(filename) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n  var listener;\n\n  var options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if ('object' == typeof arguments[1]) {\n    options = util._extend(options, arguments[1]);\n    listener = arguments[2];\n  } else {\n    listener = arguments[1];\n  }\n\n  if (!listener) {\n    throw new Error('watchFile requires a listener function');\n  }\n\n  if (inStatWatchers(filename)) {\n    stat = statWatchers[filename];\n  } else {\n    stat = statWatchers[filename] = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n  }\n  stat.addListener('change', listener);\n  return stat;\n};\n\nfs.unwatchFile = function(filename, listener) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  if (!inStatWatchers(filename)) return;\n\n  var stat = statWatchers[filename];\n\n  if (typeof listener === 'function') {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (EventEmitter.listenerCount(stat, 'change') === 0) {\n    stat.stop();\n    statWatchers[filename] = undefined;\n  }\n};\n\n// Realpath\n// Not using realpath(2) because it's bad.\n// See: http://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nfs.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nfs.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n\nvar pool;\n\nfunction allocNewPool(poolSize) {\n  pool = new Buffer(poolSize);\n  pool.used = 0;\n}\n\n\n\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  // a little bit bigger buffer and water marks by default\n  options = util._extend({\n    highWaterMark: 64 * 1024\n  }, options || {});\n\n  Readable.call(this, options);\n\n  this.path = path;\n  this.fd = options.hasOwnProperty('fd') ? options.fd : null;\n  this.flags = options.hasOwnProperty('flags') ? options.flags : 'r';\n  this.mode = options.hasOwnProperty('mode') ? options.mode : 438; /*=0666*/\n\n  this.start = options.hasOwnProperty('start') ? options.start : undefined;\n  this.end = options.hasOwnProperty('end') ? options.end : undefined;\n  this.autoClose = options.hasOwnProperty('autoClose') ?\n      options.autoClose : true;\n  this.pos = undefined;\n\n  if (this.start !== undefined) {\n    if ('number' !== typeof this.start) {\n      throw TypeError('start must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if ('number' !== typeof this.end) {\n      throw TypeError('end must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('start must be <= end');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\nfs.FileReadStream = fs.ReadStream; // support the legacy name\n\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._read(n);\n    });\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    pool = null;\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.pos !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  if (this.pos !== undefined)\n    this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0)\n        b = thisPool.slice(start, start + bytesRead);\n\n      self.push(b);\n    }\n  }\n};\n\n\nReadStream.prototype.destroy = function() {\n  if (this.destroyed)\n    return;\n  this.destroyed = true;\n\n  if ('number' === typeof this.fd)\n    this.close();\n};\n\n\nReadStream.prototype.close = function(cb) {\n  var self = this;\n  if (cb)\n    this.once('close', cb);\n  if (this.closed || 'number' !== typeof this.fd) {\n    if ('number' !== typeof this.fd) {\n      this.once('open', close);\n      return;\n    }\n    return process.nextTick(this.emit.bind(this, 'close'));\n  }\n  this.closed = true;\n  close();\n\n  function close(fd) {\n    fs.close(fd || self.fd, function(er) {\n      if (er)\n        self.emit('error', er);\n      else\n        self.emit('close');\n    });\n    self.fd = null;\n  }\n};\n\n\n\n\nfs.createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n};\n\nutil.inherits(WriteStream, Writable);\nfs.WriteStream = WriteStream;\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  options = options || {};\n\n  Writable.call(this, options);\n\n  this.path = path;\n  this.fd = null;\n\n  this.fd = options.hasOwnProperty('fd') ? options.fd : null;\n  this.flags = options.hasOwnProperty('flags') ? options.flags : 'w';\n  this.mode = options.hasOwnProperty('mode') ? options.mode : 438; /*=0666*/\n\n  this.start = options.hasOwnProperty('start') ? options.start : undefined;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if ('number' !== typeof this.start) {\n      throw TypeError('start must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('start must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if ('number' !== typeof this.fd)\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', this.close);\n}\n\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\n\n\nWriteStream.prototype.open = function() {\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      this.destroy();\n      this.emit('error', er);\n      return;\n    }\n\n    this.fd = fd;\n    this.emit('open', fd);\n  }.bind(this));\n};\n\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n\n  var self = this;\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += data.length;\n};\n\n\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n\n// SyncWriteStream is internal. DO NOT USE.\n// Temporary hack for process.stdout and process.stderr when piped to files.\nfunction SyncWriteStream(fd, options) {\n  Stream.call(this);\n\n  options = options || {};\n\n  this.fd = fd;\n  this.writable = true;\n  this.readable = false;\n  this.autoClose = options.hasOwnProperty('autoClose') ?\n      options.autoClose : true;\n}\n\nutil.inherits(SyncWriteStream, Stream);\n\n\n// Export\nfs.SyncWriteStream = SyncWriteStream;\n\n\nSyncWriteStream.prototype.write = function(data, arg1, arg2) {\n  var encoding, cb;\n\n  // parse arguments\n  if (arg1) {\n    if (typeof arg1 === 'string') {\n      encoding = arg1;\n      cb = arg2;\n    } else if (typeof arg1 === 'function') {\n      cb = arg1;\n    } else {\n      throw new Error('bad arg');\n    }\n  }\n  assertEncoding(encoding);\n\n  // Change strings to buffers. SLOW\n  if (typeof data == 'string') {\n    data = new Buffer(data, encoding);\n  }\n\n  fs.writeSync(this.fd, data, 0, data.length);\n\n  if (cb) {\n    process.nextTick(cb);\n  }\n\n  return true;\n};\n\n\nSyncWriteStream.prototype.end = function(data, arg1, arg2) {\n  if (data) {\n    this.write(data, arg1, arg2);\n  }\n  this.destroy();\n};\n\n\nSyncWriteStream.prototype.destroy = function() {\n  if (this.autoClose)\n    fs.closeSync(this.fd);\n  this.fd = null;\n  this.emit('close');\n  return true;\n};\n\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\n","undoManager":{"mark":0,"position":-1,"stack":[]},"ace":{"folds":[],"customSyntax":"javascript","scrolltop":10794,"scrollleft":0,"selection":{"start":{"row":694,"column":17},"end":{"row":694,"column":17},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":673,"state":"start","mode":"ace/mode/javascript"}}}